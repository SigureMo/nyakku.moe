---
title: Principles of Computer Composition
date: 2019-11-17
category: 墨
tags:
   - CS
   - kaoyan
---

::: tip

《计算机组成原理》复习笔记

:::

<!-- more -->

## 1 计算机系统概述

### 1.1 计算机发展历程

#### 1.1.1 计算机硬件的发展

-  计算机的四代变化

   -  第一代计算机 电子管时代
   -  第二代计算机 晶体管时代
   -  第三代计算机 中小规模集成电路时代
   -  第四代计算机 超大规模集成电路时代

-  计算机元件的更新换代

   -  摩尔定律 当价格不变时，集成电路上可容纳的晶体管数目，约每隔 18 个月便会增加一倍，性能也将提升一倍
   -  半导体存储期的发展 单芯片 1KB 到现在的 GB 级
   -  微处理器的发展 8 位到现在的 64 位（机器字长）

#### 1.1.2 计算机软件的发展

-  机器语言 面向机器
-  汇编语言 面向机器
-  高级语言 面向问题
   -  FORTRAN 科学计算和工程计算
   -  PASCAL 结构化程序设计
   -  C++ 面向对象
   -  Java 适应网络环境

### 1.2 计算机系统层次结构

#### 1.2.1 计算机系统的组成

通常来说，一个功能若使用较为频繁且用硬件实现的成本较为理想，则使用硬件解决可以提高效率，而用软件实现可以提高灵活性，但效率往往不如硬件实现高

#### 1.2.2 计算机硬件的基本组成

计算机硬件系统由**运算器**、**存储器**、**控制器**、**输入设备**和**输出设备** 5 大部件组成

-  早期的冯·诺依曼计算机

   ![PCC01.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC01.png)

   -  特点

      -  计算机由**五大部件**组成
      -  指令和数据以**同等地位**存于存储器，可按地址寻访
      -  指令和数据用二进制表示
      -  指令由**操作码**和**地址码**组成
      -  指令在存储器内**按顺序存放**
      -  以运算器为中心

-  现代计算机的组织结构

   以存储器为中心，使 I/O 操作尽可能地绕过 CPU ，直接在 I/O 设备和存储器之间完成，以提高系统的整体运行效率

   ![PCC02.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC02.png)

-  计算机的功能部件

   -  输入设备 将信息转换成机器能识别的形式
   -  输出设备 将结果转换成人们熟悉的形式
   -  存储器 用来存放程序和数据

      -  主存储器

         -  存储体 存放二进制信息
         -  地址寄存器 MAR 存放访存地址，经过地址译码后找到所选的存储单元

            由于其用于寻址，所以其位数对应着存储单元的个数，与 PC 位数相等

         -  数据寄存器 MDR 主存和其他部件的中介机构，用于暂存要从存储器读或写的信息

            MDR 的位数和存储字长相等，一般为字节的二次幂倍

      -  辅助存储器

   -  运算器 完成算术运算和逻辑运算

      -  算数逻辑单元 ALU
      -  若干通用寄存器
         -  累加器 ACC
         -  乘商寄存器 MQ
         -  操作数寄存器 X
         -  变址寄存器 IX
         -  基址寄存器 BR
         -  程序状态寄存器 PSW

   -  控制器 指挥各部件自动协调地进行工作

      -  程序计数器 PC 用来存放当前欲执行指令的地址，可以自动加一以形成下一条指令的地址，它与主存的 MAR 之间有一条直接通路
      -  指令寄存器 IR 用来存放当前的指令，其内容来自主存的 MDR

   ![PCC03.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC03.png)

   主机包含 CPU 和主存，其他的硬件装置统称外设，主要为外存和 I/O 设备

   另外，现代计算机的 CPU 通常还集成了 Cache 、 MAR 、MDR ，而不是在主存里

#### 1.2.3 计算机软件的分类

-  系统软件
   -  操作系统（OS）
   -  数据库管理系统（DBMS）
   -  语言处理程序
   -  分布式软件系统
   -  ……
-  应用软件 按任务需要编制成的各种程序

#### 1.2.4 计算机的工作过程

1. 把程序和数据装入主存储器
2. 从程序的起始地址运行程序
3. 用程序的首地址从存储器中取出第一条指令，经过译码、执行步骤等控制计算机各功能部件协同运行，完成这条指令功能，并计算下一条指令的地址
4. 用新得到的指令地址继续当初第二条指令并执行，直到程序结束为止；每条指令都是在**取指、译码和执行**的循环过程中完成的

以取数指令为例

-  ==取指==： PC $\to$ MAR $\to$ M $\to$ MDR $\to$ IR
-  ==分析==： OP(IR) $\to$ CU
-  ==执行==： Ad(IR) $\to$ MAR $\to$ M $\to$ MDR $\to$ ACC

此外，每取完一条指令还须为取下一条指令做准备，形成下一条指令的地址，即 (PC) + 1 $\to$ PC

#### 1.2.5 计算机系统的多级层次结构

-  软件

   1. 高级语言 虚拟机器 M4 用编译程序翻译成汇编语言程序
   2. 汇编语言 虚拟机器 M3 用汇编程序翻译成机器语言程序
   3. 操作系统 虚拟机器 M2 用机器语言解释操作系统

   ***

-  硬件

   4. 机器语言 实际机器 M1 用微指令解释机器指令
   5. 微指令系统 微程序机器 M0 由硬件直接执行微指令

### 1.3 计算机的性能指标

#### 1.3.1 计算机的主要性能指标

-  机器字长

   指计算机进行一次整数运算**所能处理的二进制数据的位数**，通常与 CPU 的寄存器位数、加法器有关，因此，机器字长一般等于内部寄存器的大小

   ::: tip 机器字长、指令字长、存储字长的区别和联系

   -  机器字长： 计算机能直接处理的二进制数据位数
   -  指令字长： 一个**指令字**中包含的二进制代码的位数
   -  存储字长： 一个**存储单元**存储的二进制代码的长度

   :::

-  数据通路带宽

   指数据总线一次所能并行传送信息的位数

-  主存容量

   主存所能存储信息的最大容量，可用字数 $\times$ 字长表示

-  运算速度
   -  吞吐量和响应时间
      -  吞吐量 指系统在单位时间内处理请求的数量
      -  响应时间 指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间
   -  主频和 CPU 时钟周期
      -  CPU 时钟周期 主频的倒数
      -  主频（CPU 时钟频率）
   -  CPI 执行一条指令所需时钟周期数
   -  MIPS、MFLOPS、GFLOPS、TFLOPS
      -  MIPS 每秒可以执行多少百万条指令
      -  MFLOPS 每秒执行多少百万次浮点运算
      -  GFLOPS 每秒执行多少十亿次浮点运算
      -  TFLOPS 每秒执行多少万亿次浮点运算

#### 1.3.2 几个专业术语

-  透明性 指站在某类用户的角度，感觉不到某个事物或属性的存在，即“看”不到
-  兼容 指计算机软件或硬件的通用性
-  固件 指将程序固定在 ROM 中组成的部件

### 1.4 计算机的发展与应用 <Badge text="~" type="tip"/>

#### 1.4.1 计算机的应用

-  科学计算和数据处理
-  工业控制和实时控制
-  网络技术
   -  电子商务
   -  网络教育
   -  敏捷制造
-  虚拟现实
-  办公自动化和管理信息系统
-  CAD / CAM / CIMS
-  多媒体技术
-  人工智能

#### 1.4.2 计算机的展望

-  计算机具有类似人脑的一些超级智能功能

   要求计算机的速度要足够快

-  芯片集成度的提高受一下三方面的限制
   -  芯片集成度受物理极限的制约
   -  按几何级数递增的制作成本
   -  芯片的功耗、散热、线延迟
-  替代传统的硅芯片

   -  光计算机

      利用光子取代电子进行运算和存储

   -  DNA 生物计算机

      通过控制 DNA 分子间的生化反应

   -  量子计算机

      利用原子所具有的量子特性

## 2 数据的表示和运算

### 2.1 数制与编码

#### 2.1.1 进位计数制及其相互转换

我们常用的计数方法为十进制，但它也只是一种对数字的表示方法而已，在计算机中更常用的是二进制，为了增加可读性，同时引入了十六进制和八进制

很明显，二进制与十六进制、二进制与八进制都是可以非常轻易的相互转换的，任何进制与十进制相互转换也是很容易的，故不赘述

::: tip

计算机整数是连续表示的，但是小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示，例如 0.3，但是任何一个二进制小数都可以用十进制小数表示

:::

#### 2.1.2 真值和机器数

-  真值是我们想要表示的真实的数值

-  机器数是在计算机中表示真值的方法，比如原码、补码、反码和移码

#### 2.1.3 BCD 码

使用二进制来编码十进制数，通常使用 4 位二进制数来表示一位十进制数，很明显会有 6 种冗余状态

常用的 BCD 码如下

-  8421 码，有权码，各位权重分别为 8421
-  余 3 码，无权码，在 8421 码的基础上加 $(0011)_2$
-  2421 码，有权码，各位权重分别为 2421，特点是大于等于 5 的四位二进制树中最高位为 1

#### 2.1.4 字符与字符串

与数字一样，字符在计算机中也是需要经过编码后才能表示的

-  字符编码 ASCII 码

   使用 7 位二进制编码表示 128 个字符

   ::: tip 为什么 0~9 对应 ASCII 码 48~57？

   因为 48 二进制形式为 0110000 ，去掉高三位即 0，其他数字亦然

   :::

-  汉字的表示和编码

   使用更多字节以表示其他文字等字符

-  字符串的存放

   也即连续的一串字符，但是需要区分大端模式和小端模式

   ::: tip 什么是大端模式和小端模式

   用一个例子来说明：大端和小端分别如何存储 `0x12345678`

   -  大端模式会将 `0x12` 存储在这个高字节存储在低位地址，所以该连续四字节应该分别为 `0x12` `0x34` `0x56` `0x78`，地址依次增高，这其实符合人们的阅读习惯
   -  小端模式正好相反，它会将 `0x12` 这个高字节存储在高位地址，也就是 `0x78` `0x56` `0x34` `0x12` ，虽然不满足人们的阅读习惯，但是它更具有解释性，如果将其看作连续的一个数据，它就是 `0x12345678`

   :::

#### 2.1.5 校验码

数据校验码的码距：任何两个合法码字之间最少变化的二进制位数

对于码距不小于 2 的数据校验码，开始具有检错能力，且码距越大，检错、纠错能力越强，检错能力总是大于等于纠错能力

-  奇偶校验码

   加上一个二进制位后，使得**整个校验码**中 1 的个数为奇（偶）数个，只能检奇数个错误，不能纠错

-  海明（汉明）校验码

   使用一个简单的例子来讲解汉明码的编码方式：

   **在 n = 4，k = 3 时，求 1010 的汉明码**

   -  首先 ==确定校验位的分布==（$2^{i-1}$ 位），本例中即为 1、2、4 位，故海明码各位分别为 $D_4, D_3, D_2, P_3, D_1, P_2, P_1$
   -  然后 ==分组形成校验关系==，比如 $D_1$ 放在第 3 位，则由 $P_1$（第一位）与 $P_2$（第二位）共同校验，$D_4$ 由 $P_1$（第一位）、$P_2$（第二位）与 $P_3$（第四位）共同校验，其余同理
   -  ==确定校验位取值==，取值为由该校验位所校验的各位求异或，比如 $P_1$ 校验了 $D_1$、$D_2$ 与 $D_4$ ，故 $P_1 = D_1 \oplus D_2 \oplus D_4$
   -  利用校验位进行 ==校验==，对每个校验组求异或，比如 $S_1 = P_1 \oplus D_1 \oplus D_2 \oplus D_4$ ，依次求出 $S_3S_2S_1$ ，如果结果为 000 ，则无错，否则有错，且该值为错误的位号，比如 $S_3S_2S_1 = 110$ ，则可知第六位出错

-  循环冗余校验（CRC）码

   在 K 位信息码后拼接 R 位校验码，R 位校验码是利用发送端与接收端共同约定的生成多项式得到的

   同样是使用一个简单的例子来说明：

   **设生成多项式为 $G(x) = x^3 + x^2 + 1$ ，信息码为 101001，求对应的 CRC 码**

   -  首先将原信息码左移 R 位，低位补 0，得到 101001000
   -  然后对移位后的信息码，用生成多项式进行模 2 出发，产生余数

      ::: tip 什么是模 2 除法与模 2 减法

      既不进位也不借位的运算，故模 2 减法与模 2 加法的结果相同，都是逐位异或运算，模 2 除法类似于算数除法，减法时使用的是模 2 减法

      :::

      ![PCC04.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC04.png)

   -  将余数拼接在左移后的编码后，这里将 001 拼接在 101001 后，即 101001001
   -  检错和纠错，接收端对接收到的 CRC 码用生成多项式做模 2 除法，若余数为 0 ，则无错，否则余数即指示错误的位

### 2.2 定点数的表示与运算

#### 2.2.1 定点数的表示

-  无符号数和有符号数的表示

   -  无符号数
   -  有符号数 使用 0 代表正号， 1 代表负号

-  机器数的定点表示

   -  定点小数（纯小数） 小数点隐含在符号位之后、有效数值位之前
   -  定点整数（纯整数） 小数点隐含在有效数值为之后

-  原码、反码、补码、移码

   用 1bit 符号位 + 2bit 有效数值位的简单例子来说明

   > 第一行列出了当原码为 000、001……时对应的**真值**，其他行类似

   |      | 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111 |
   | ---- | --- | --- | --- | --- | --- | --- | --- | --- |
   | 原码 | 0   | 1   | 2   | 3   | -0  | -1  | -2  | -3  |
   | 反码 | 0   | 1   | 2   | 3   | -3  | -2  | -1  | -0  |
   | 补码 | 0   | 1   | 2   | 3   | -4  | -3  | -2  | -1  |
   | 移码 | -4  | -3  | -2  | -1  | 0   | 1   | 2   | 3   |

   ::: warning

   如未特殊说明，各种转换都不带符号位，保证符号位不变

   :::

   -  原码 很简单，就是直接将最高位作为符号位，正为 0，负为 1，数值部分即为绝对值，很明显，它有两个 0，正负两部分相互独立，只要越界就溢出了
   -  反码 正数不变，负数对原码的数值部分取反，但是这样好像还是没什么太大用处（也许对称看着能好看些），但是可作为运算补码的中介
   -  补码 正数仍然不变，负数是反码 +1（码是 +1，真值自然会每个都 -1），这样我们不仅解决了 0 有两个（浪费一个可表示的数字），还使得正数域与负数域拼接起来了，0 - 1 很自然的就等于 -1 ，并不会有溢出，同时也大大降低了加法运算的难度

   ::: tip 补码运算的技巧

   -  对补码进行补码运算可得原码
   -  对补码进行**带上符号位的补码运算**可得其相反数的补码

   :::

   -  移码 将负数域与正数域调换一下（加个偏移量即可），保持了数据原有的大小顺序，移码大真值就大，移码小真值就小

#### 2.2.2 定点数的运算

-  溢出判断

   -  一位符号位判溢出

      正正或者负负可能溢出，溢出后符号改变，故可使用**最高有效位的进位 $\oplus$ 符号位的进位 = 1**判断溢出

   -  两位符号位判溢出

      额外增加一位符号位，**如果结果的双符号位相同则未溢出，如果不同则溢出**，而且最高符号位代表其真正的符号

-  定点数的移位运算

   -  算术移位

      针对有符号数，移位过程中**保持符号位不变**

      -  正数 移位后出现的空位均以 0 填补
      -  负数 移位后出现的空位填补方式如下

         | 码制 | 添补代码            |
         | ---- | ------------------- |
         | 原码 | 0                   |
         | 补码 | 左移添 0 / 右移添 1 |
         | 反码 | 1                   |

      ::: tip 为什么负数的填补代码都不一样？

      因为负数的 0 的表示方法不一样，但是我们很容易知道原码应当填 0、反码应当填 1，而补码稍微复杂一些，从一个例子讲起

      ```
      10011|100 （原码）
      11100|011 （反码）
      11100|100 （补码）
      ```

      我们能发现一个规律，补码从右向左一直到第一个 1 ，都是和原码相同的，而再左面的都是和反码相同的，所以，补码右侧（左移）填补应该与原码相同，填 0，相应的，左侧（右移）填补应该与补码相同，填 1

      :::

   -  逻辑移位

      针对无符号数，所以无论左移右移，直接填 0 就好了

   -  循环移位

      移出的数位又被移入数据中，而是否带进位则要看是否将进位标志加入循环位移，循环移位操作特别适合将数据的低字节部分与高字节部分互换

-  定点数的加减法运算

   -  原码定点数的加减法运算

      需要考虑加还是减，并判断正负号，就很麻烦

   -  补码定点数的加减法运算

      符号位也参与运算，加法即两个补码直接相加，减法即加上减数的负数的补码

-  定点数的乘法运算

   -  原码一位乘法

      符号位和数值部分分开求

      -  符号位 两个符号的异或
      -  数值部分

         -  已经使用过的乘数最低位会在逻辑右移中被丢弃，高位补 0，这样之前运算得到的溢出得到的“符号位”便参与运算了
         -  另外需要一个计数器记录移位次数，以判断乘数是否全部计算过，另外记得最后要把乘数的最高位也移走才是最终答案
         -  这里考虑到定点小数运算时可能出现绝对值大于 1 的情况（并未溢出），所以部分积和被乘数取双符号位

      ::: tip 例

      $x = -0.1101, y = 0.1011$

      ![PCC11.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC11.png)

      -  符号位由异或求得为 `1`
      -  数值部分为 `0.10001111`

      即结果为 `-0.10001111`

      :::

   -  补码一位乘法（Booth 算法）

      -  符号位参与运算，运算的数均以补码表示
      -  乘数末位增加附加位 $y_{n+1}$ ，且初值为 0
      -  根据 $(y_n, y_{n+1})$ 的取值来确定操作（如下表）

         | $y_n$ | $y_{n+1}$ | 操作                                   |
         | ----- | --------- | -------------------------------------- |
         | 0     | 0         | 部分积右移一位                         |
         | 0     | 1         | 部分积加 $[X]_{complement}$，右移一位  |
         | 1     | 0         | 部分积加 $[-X]_{complement}$，右移一位 |
         | 1     | 1         | 部分积右移一位                         |

      ::: tip 例

      $x = -0.1101, y = 0.1011$

      ![PCC12.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC12.png)

      即结果的补码为 `1.01110001`，真值为 `-0.10001111`

      :::

-  定点数的除法运算

   -  原码除法运算

      同原码乘法，需要将符号位与数值部分分开计算

      -  恢复余数法

         当余数为负时，都需要再加上除数将余数恢复为正值，这将大大增加除法时间，所以一般不用

      -  加减交替法

         -  余数为正数时，下一步就直接减就好了
         -  余数为负数时，商上 0，在下一步加除数（替换下一步的减，当前步无需额外操作）即可，不需要再额外增加恢复余数这一步了

         ::: tip 例

         $x = 0.1011, y = 1.0011$

         ![PCC13.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC13.png)

         -  符号位为 `0`
         -  数值部分为 `0.1101` 余 `0.0111`

         即结果为 $+0.1101$ 余 $0.0111 \times 2^{-4}$

         :::

   -  补码除法运算

      同样的，补码也是有恢复余数法和加减交替法，但是恢复余数法一般不用，所以略去，另外，补码除法和补码乘法一样，是不需要单独算符号位的

      -  恢复余数法（略）
      -  加减交替法

         -  若余数与除数同号，则代表上一次够减，商上 `1`，下一次做减法
         -  若余数与除数异号，则代表上一次不够减，商上 `0`，下一次做加法
         -  末位恒置 `1`

         ::: tip 例

         $x = 0.1000, y = -0.1011$

         ![PCC14.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC14.png)

         -  符号位为 `0`
         -  数值部分补码为 `1.0101` 余 `0.0111`

         即结果为 $-0.1011$ 余 $0.0111 \times 2^{-4}$

         :::

#### 2.2.3 强制类型转换

-  同等字长不同类型的变量转换（比如 `short` 与 `unsigned short`），将会保留存储时的位值（补码），按照新的类型重新解释

   ::: tip 例

   将 `short x = -4312` 强制转换为 `unsigned short y`

   | 变量 | 值    | 补码                  |
   | ---- | ----- | --------------------- |
   | x    | -4321 | `1110 1111 0001 1111` |
   | y    | 61215 | `1110 1111 0001 1111` |

   结果为 `y = 61215`

   :::

-  大字长变量向小字长变量转换时（比如 `int` 向 `short`），将会将大字长变量高字节部分直接截断

   ```c
   int x1 = 0x7fffffff;
   short y1 = (short) x1;
   printf("%hx\n", y1);        // ffff
   ```

-  小字长变量向大字长变量转换时（比如 `short` 向 `int`），不仅将低字节部分复制过去，而且要对符号位进行扩展补充，以保证数值是不变的

   ```c
   short x2 = 0x8fff;
   int y2 = (int) x2;
   printf("%x\n", y2);         // ffff8fff
   ```

### 2.3 浮点数的表示与运算

#### 2.3.1 浮点数的表示

-  浮点数的表示格式

   $N = r^E \times M$

   就是以 2 为底的科学计数法啦，只不过这里要求尾数不大于 1，也就是一个纯小数啦，如果是标准化的话，小数点后第一位也要是 1（原码）

   总的来说，就是**阶符、阶码; 数符、尾数**，用原码还是补码什么的看要求

-  规格化浮点数

   -  规格化格式

      数值部分范围 $[\frac{1}{2}, 1)$，但是补码负数有点特殊，范围为 $[-1, -\frac{1}{2})$

      即原码小数点后第一位必为 `1`(`0.1xxx` 与 `1.1xxx` 均为规格化)，而补码符号位与尾数最高位相反（`0.1xxx` 与 `1.0xxx` 均为规格化）

      另外，**基数越大**可表示的浮点数**范围越大**随之**精度降低**哦

   -  规格化方法

      -  左规 即经过运算后不满足规格化，需尾数左移，阶码减一（可能进行多次）
      -  右规 尾数溢出时（可用双符号位判断 `01.xxx/10.xxx`），尾数右移，阶码加一

-  浮点数表示范围

   ![PCC15.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC15.png)

   -  上溢 需进行溢出处理
   -  下溢 当做机器零处理

-  IEEE 754 标准

   ![PCC16.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC16.png)

   -  数符 1 位
   -  阶码 移码表示
   -  尾数 原码表示，由于最高位必为 `1`，为了能够表示更多有效位，这个 `1` 将隐含

   | 类型       | 数符 | 阶码 | 尾数数值 | 总位数 |
   | ---------- | ---- | ---- | -------- | ------ |
   | 短浮点数   | 1    | 8    | 23       | 32     |
   | 长浮点数   | 1    | 11   | 52       | 64     |
   | 临时浮点数 | 1    | 15   | 64       | 80     |

-  定点、浮点表示的区别

   -  范围 浮点范围增加
   -  精度 由于浮点有着很多位表示阶码，所以精度降低
   -  数的运算 浮点运算要对阶码和尾数运算，最后还要规格化，比较复杂
   -  溢出问题 尾数溢出可以右规，阶码溢出才是真的溢出

#### 2.3.2 浮点数的加减运算

1. 对阶 使用不嘛求阶差，小阶向大阶看齐
2. 尾数求和 将对阶后的尾数按定点数加（减）规则运算
3. 规格化 左规或右规
4. 舍入
   -  `0` 舍 `1` 入法： 类似于十进制的四舍五入
   -  恒置 `1` 法
5. 溢出判断
   -  上溢 中断处理
   -  下溢 按机器零处理

#### 2.3.3 强制类型转换

$char \to int \to long \to double$ 范围和精度都从小到大，可以放心转换，不会有损失（溢出或者精度损失）

值得注意的是， $int \to float$ 虽然不会发生溢出，但是是可能进行舍入的，因为 $float$ 尾数部分（24bit）比 $int$ 数值（32bit）少，所以最后几位可能会发生舍入

```c
int x3 = 0x7fffffff;
float y3 = (float) x3;
printf("%d %f\n", x3, y3);  // 2147483647 2147483648.000000
```

### 2.4 算数逻辑单元（ALU）

#### 2.4.1 串行加法器和并行加法器

-  一位全加器

   全加器（FA）

   -  输入
      -  加数 $A_i$
      -  加数 $B_i$
      -  低位进位 $C_{i-1}$
   -  输出
      -  本位 $S_i = A_i \oplus B_i \oplus C_{i-1}$
      -  进位 $C_i = A_i B_i + (A_i \oplus B_i) C_{i-1}$

-  串行加法器

   只有一个全加器，数据逐位送入加法器中进行运算，所以运算慢

-  并行加法器

   多个全加器组成，各位同时运算，但是仍有一个制约其速度的最大问题：虽然各位同时提供，但是进位必须在低位计算结束后才能得到

   -  串行进位链

      正如上面所述，高位仍然需要等待低位的进位，速度仍然受限

   -  并行进位链

      在高位的表达式中直接带入低位进位的结果，当然这样越高位表达式越复杂，对应的逻辑电路也就越复杂，但这确实解决了速度的问题

   -  分组并行进位方式

      为了防止电路过于复杂，并获得比较可以接受的速度，可以对全加器进行分组，在组内使用并行进位链，组间需要分情况

      -  单级先行进位方式

         组内使用并行进位链，组间使用串行进位链

      -  多级先行进位方式

         相似的，这次使用的是分级的思想，还是需要分组，组内并行进位链，组间也是并行进位链

#### 2.4.2 算数逻辑单元的功能和结构

ALU 核心是一个并行加法器，同时能执行“与或非”等逻辑运算

![PCC17.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC17.png)

-  输入
   -  $A_i$ $B_i$，输入变量
   -  $K_i$ 控制信号，用于控制做何种运算
-  输出
   -  $F_i$ 运算结果

## 3 存储系统

### 3.1 存储器的层次结构

#### 3.1.1 存储器的分类

-  按在计算机中的作用（层次）分类

   -  主存储器（主要由 DRAM 组成）
   -  辅助存储器
   -  高速缓冲存储器（Cache， 主要由 SRAM 组成）

-  按存储介质分类

   > 本质上只有 3 种：半导体、磁、光

   -  半导体存储器 TTL、MOS $\to$ 易失
   -  磁表面存储器 磁头、载磁体
   -  磁芯存储器 硬磁材料、环状元件 $\to$ 非易失
   -  光盘存储器 激光、磁光材料

-  按存取方式分类

   -  存取时间与物理地址无关（随机访问）
      -  随机存储器（RAM） 在程序的执行过程中可读可写
      -  只读存储器（ROM） 在程序的执行过程中只读
   -  存取时间与物理地址有关（串行访问）
      -  顺序存取存储器 磁带
      -  直接存取存储器 磁盘

-  按信息的可保存性分类

   -  易失性存储器 断电后存储信息即消失的存储器，如 RAM
   -  非易失性存储器 断电后信息仍然保持的存储器，如 ROM、磁表面存储器、光存储器

   ::: tip 破坏性读出与非破坏性读出

   破坏性读出指某个存储单元所存储的信息被读出时，原存储信息被破坏，必须进阶一个再生的操作以便，恢复被破坏的信息

   如果没有被破坏，则为非破坏性读出

   :::

### 3.1.2 存储器的层次化结构

![PCC05.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC05.png)

![PCC06.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC06.png)

-  Cache - 主存 层次用于解决 CPU 与主存速度不匹配的问题，由硬件自动完成
-  主存 - 辅存 层次用于解决存储系统的容量问题，由硬件和操作系统共同完成

### 3.2 主存储器

#### 3.2.1 主存的性能指标

-  存储容量 = 存储字数 $\times$ 字长（前者表示寻址范围，后者表示一次存取的数据量）
-  单位成本：每位价格 = 总成本 / 总容量
-  存储速度：数据传输率 = 数据的宽度 / 存储周期
   -  存取时间 存储器的**访问时间** （读出时间 写入时间）
   -  存取周期 **连续**两次**独立**的存储器操作所需的**最小间隔时间** （读周期 写周期），它不仅包含了存取时间，还包括了恢复时间
   -  主存带宽 位/秒

#### 3.2.2 半导体芯片简介

-  半导体存储芯片的基本结构

   ![PCC07.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC07.png)

   -  片选线 确定哪个存储芯片被选中
   -  地址线 单向
   -  数据线 双向

-  半导体存储芯片的译码驱动方式

   -  线选法

      不需要地址译码器，但是不能充分利用系统的存储器空间，将需要很庞大的地址线数

   -  译码片选法

      利用少量地址线（$\log_2 n$）完成片选，比如利用 8 片 $8K \times 8bit$ 的存储芯片组成 $64K \times 8bit$ 的存储器，则可将 13bit 作为片内寻址信号，剩余 3bit 作为片选信号，将该 3bit 接入译码器即可得到 8bit 的片选信号，比如 000 选中第 1 片，会在第一片片选线处产生一个低电平，其余 7 片均为高电平

#### 3.2.3 随机存取存储器（RAM）

-  静态 RAM（SRAM）

   -  存储元 双稳态**触发器**
   -  易失性半导体存储器（断电数据消失）
   -  非破坏性读出
   -  一般用作 Cache
   -  特点
      -  存取速度快
      -  集成度低，功耗较大

-  动态 RAM（DRAM）

   -  存储元 栅极**电容**上的电荷
   -  与 SRAM 比需要的晶体管更少，容易集成、价位低、容量大、功耗低，但速度慢一些，一般用于主存
   -  电容上的电荷一般只能维持 1~2ms，故每隔一段时间就需要刷新（通常取 2ms），刷新只与**行地址**有关，每次刷新刷新一行数据，而不是某一存储单元数据

      -  **集中刷新（存取周期为 0.5μs）**

         在一个刷新周期内，利用一段固定的时间，以此对存储器所有行进行逐一再生

         存在死区，那段时间 CPU 是无法读写数据的

      -  **分散刷新（存取周期为 1μs）**

         一个存储器的系统工作周期分为两部分：前半部分正常读、写或保持，后半部分用于刷新某一行

         不存在死区，但由于过度刷新，效率降低

      -  **分散刷新与集中刷新相结合（异步刷新）**

         每 15.6μs 刷新一行，2ms 刚好刷新 128 行，如果将刷新安排在指令译码阶段，不会出现死区

-  存储器的读、写周期

   -  RAM 的读周期 片选线 $\overline{CS}$ 低电平、写允许信号 $\overline{WE}$ 高电平
   -  RAM 的写周期 片选线 $\overline{CS}$ 低电平、写允许信号 $\overline{WE}$ 低电平

   都要保持到输出/输出稳定

-  动态 RAM 和静态 RAM 的比较

   |            | DRAM     | SRAM   |
   | ---------- | -------- | ------ |
   | 存储原理   | 电容     | 触发器 |
   | 刷新       | 有       | 无     |
   | 送行列地址 | 分两次送 | 同时送 |
   | 速度       | 低       | 高     |
   | 集成度     | 高       | 低     |
   | 芯片引脚   | 少       | 多     |
   | 功耗       | 小       | 大     |
   | 价格       | 低       | 高     |
   | 主要用途   | 主存     | 缓存   |

#### 3.2.3 只读存储器（ROM）

-  掩模 ROM（MROM）

   制造商写入，无法更改

   -  行列选择线交叉处有 MOS 管为“1”
   -  行列选择线交叉处无 MOS 管为“0”

-  PROM（一次性编程）

   用户可利用专门的设备进行写入，且不可修改

   -  熔丝断为“0”
   -  熔丝未断为“1”

-  EPROM（多次性编程）

   N 型沟道浮动栅 MOS 电路，紫外线全部擦洗

   -  D 端加正电压 形成浮动栅 S 与 D 不导通为“0”
   -  D 端不加正电压 不形成浮动栅 S 与 D 导通为“1”

-  EEPROM（多次性编程）

   -  电可擦写
   -  局部擦写
   -  全部擦写

-  Flash Memory(闪速型存储器)

   既可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写，且擦除重写的速度快

-  固态硬盘（Solid State Drives, SSD）

   基于闪存，由控制单元和存储单元组成

#### 3.2.4 主存储器与 CPU 的连接

-  连接原理

   主存通过数据总线、地址总线、控制总线与 CPU 连接

   -  数据总线 位数与工作频率的乘积正比于数据传输率
   -  地址总线 位数决定了可寻址的最大内存空间
   -  控制总线 指出总线周期的类型和本次输入/输出操作完成的时刻

-  主存容量的扩展

   -  位扩展法（增加存储字长）

      比如用 2 片`1K X 4位`存储芯片组成`1K X 8位`的存储器，需求是 10 根地址线、8 根数据线，材料是 10 根地址线、4 根数据线，所以就需要将两个芯片地址线直接接入，而数据线则是各占一半，以达到对某一地址数据同时进行读写

      ![PCC08.png{copyright:MOOC}](../img/Principles_of_Computer_Composition/PCC08.png)

   -  字扩展法

      比如用 2 片`1K X 8位`存储芯片组成`2K X 8位`的存储器，需求是 11 根地址线、8 根数据线，材料是 10 根地址线、8 根数据线，数据线直接接入就好，而多出来的那根地址线可作为片选择线（CS），便可对两个存储芯片地址进行衔接

      ![PCC09.png{copyright:MOOC}](../img/Principles_of_Computer_Composition/PCC09.png)

   -  字、位同时扩展法

      比如用 8 片`1K X 4位`存储芯片组成`4K X 8位`的存储器，先考虑位扩展，每组用 2 个存储芯片组成`1K X 8位`的存储器，然后再考虑字扩展，利用片选译码将额外两根地址线分配到四组存储器中

      ![PCC10.png{copyright:MOOC}](../img/Principles_of_Computer_Composition/PCC10.png)

-  存储器与 CPU 的连接
   -  合理选择存储芯片
   -  地址线的连接
   -  数据线的连接
   -  读/写命令线的连接 $\overline{WE}$ 低电平为写，高电平为读
   -  片选线的连接 访存控制信号（$\overline{MREQ}$）低电平有效
   -  其他 时序、负载

#### 3.2.5 提高访存速度的措施

解决 CPU 速度与存储体访问速度不匹配问题

-  采用高速器件
-  采用层次结构 Cache - 主存
-  调整主存结构

   -  采用并行技术

      **双端口 RAM** 同一个存储器有左、右两个独立的端口，分别具有两组互相独立的地址线、数据线和读写控制线，但是如果两端同时访问同一个地址，并且其中一个在写数据，就会发生错误，为解决该问题，可设一个 $\overline{BUSY}$ 位

   -  多模块存储器

      -  单体多字系统 增加存储字长，但这样使得存储字作为整体，产生了很多麻烦
      -  多体并行系统

         -  **高位交叉** 适合提供存储体容量，并不适合提高存储体带宽，但也给并行存储提供了基础
         -  **低位交叉** 各个体轮流编址，适合提高存储体带宽，多存储体轮流存取，解决了 CPU 与存储器速度差异的问题

         ::: tip 为什么低位交叉可以提高存储器带宽？

         首先我们回顾存取周期（存取时间 + 恢复时间），恢复时间其实也占了很大一部分，如果我们使用高位交叉，因为连续的地址是在同一个模块的，所以读取完一个字后，需要等待该模块恢复后才能继续读下一个字

         而低位交叉就不一样啦，我们可以像流水线一样连续读取数据，因为连续编址的两个字并不是在同一个模块的，我们不需要等待它恢复就可以读下一个模块，所以它大大提升了存储器带宽

         :::

   -  高性能存储芯片

      -  SDRAM(同步 DRAM)

         在系统时钟的控制下进行读出和写入

      -  RDRAM

      -  带 Cache 的 DRAM

         有利于*猝发式读取*

### 3.3 高速缓冲存储器

解决 CPU 与主存速度不匹配问题

#### 3.3.1 程序访问的局部性原理

-  **时间局部性**：是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问

-  **空间局部性**：是指一旦程序访问了某个存储单元，则不久之后其附近的存储单元也将被访问

#### 3.3.2 Cache 的基本工作原理

-  主存和缓存的编址

   主存和缓存按块存储，块的大小相同

-  命中与未命中

   -  读
      -  命中则对 Cache 进行读操作
      -  未命中则访问主存，并 ==将此字所在的块一次性从主存调入 Cache==（若 Cache 未满则调入，若满则执行替换算法并调入）
   -  写

      > 全写法与非写分配法合用，写分配法与写会法合用

      -  命中

         -  全写法（写直通法）

            Cache 与主存一直同步，实现简单但容易频繁对某个内存写入

         -  写回法

            Cache 在替换时才写回，虽然解决了上面的频繁写的问题，但复杂且使得多核（每个核心带 Cache）Cache 不同步等问题

      -  未命中

         -  写分配法

            加载目标写入块到 Cache 中，在 Cache 中进行写入

         -  非写分配法

            只写入主存，不进行调块

*  Cache 的命中率：与 Cache 的容量与块长有关
*  Cache-主存系统的效率（时间比）

#### 3.3.3 Cache 和主存的映射方式

| 方法       | 特点                                                     | 优缺点             |
| ---------- | -------------------------------------------------------- | ------------------ |
| 直接映射   | 某一主存块**只能固定**映射到**某一**缓存块               | 不灵活、速度快     |
| 全相联映射 | 某一主存块**能**映射到**任一**缓存块                     | 利用率高、速度慢   |
| 组相联映射 | 某一主存块**只能**映射到**某一**缓存**组**中的**任一块** | 两者折中，使用较多 |

#### 3.3.4 Cache 中主存块的替换算法

-  随机算法 随机地确定替换的 Cache 块
-  先进先出（FIFO）算法 并没有提现程序的局部性原理
-  近期最少使用（LRU）算法
-  最不经常使用算法

#### 3.3.5 Cache 的改进

-  增加 Cache 的级数（L1、L2、L3 Cache）
-  统一缓存和分立缓存 $\to$ 指令 Cache 与数据 Cache 分立

### 3.4 辅助存储器

解决主存容量问题

#### 3.4.1 概述

-  特点 不直接与 CPU 交换信息
-  磁表面存储器的技术指标

   -  记录密度 道密度 位密度
   -  存储容量
   -  平均寻址时间 寻道时间 + 等待时间

      辅存的速度 = 寻址时间 + 磁头读写时间

   -  数据传输率

      误码率 出错信息位数与读出信息的总位数比值

#### 3.4.2 硬磁盘存储器

-  硬磁盘存储器的类型
   -  固定磁头和移动磁头
   -  可换盘和固定盘
-  硬磁盘存储器结构

   -  磁盘驱动器
   -  磁盘控制器
      -  接收主机发来的命令，转换成磁盘驱动器的控制命令
      -  实现主机和驱动器之间的数据格式转换
      -  控制磁盘驱动器读写
      -  是主机与磁盘驱动器之间的接口

-  磁盘的性能指标

   -  磁盘的容量
   -  记录密度
   -  平均存取时间
   -  数据传输率

-  磁盘地址

   `驱动器号 柱面（磁道）号 盘面号 扇区号`

-  磁盘阵列

   -  RAID0 无冗余和无校验的磁盘序列
   -  RAID1 镜像磁盘阵列
   -  RAID2 采用纠错的海明码的磁盘阵列
   -  RAID3 位交叉奇偶校验的磁盘阵列
   -  RAID4 块交叉奇偶校验的磁盘阵列
   -  RAID5 无独立校验的奇偶校验磁盘阵列

#### 3.4.3 软磁盘存储器 <Badge text="~" type="tip"/>

-  与硬盘的对比

   |      | 硬盘                     | 软盘     |
   | ---- | ------------------------ | -------- |
   | 速度 | 高                       | 低       |
   | 磁头 | 固定、活动               | 活动     |
   |      | 浮动                     | 接触盘片 |
   | 盘片 | 固定盘、盘组大部分不可换 | 可换盘片 |
   | 价格 | 高                       | 低       |
   | 环境 | 苛刻                     |          |

-  软盘片

   由聚酯薄膜制成，不过反正没人用啦已经……

#### 3.4.4 光盘存储器

-  概述

   采用光存储技术 利用激光写入和读出

   -  第一代光存储技术 采用非磁性介质 不可采写
   -  第二代光存储技术 采用磁性介质 可擦写

-  光盘类型
   -  CD-ROM 只读型
   -  CD-R 只可写入一次型
   -  CD-RW 可读可写
   -  DVD-ROM 高容量的 CD-ROM

#### 3.4.5 固态硬盘

使用 Flash Memory 作为硬盘来记录数据，同时还需要硬件和软件的支持

#### 3.4.6 虚拟存储器

详情见[·计算机操作系统 - 虚拟存储器·](./Operating_System.html#_4-6-虚拟存储器的基本概念)章节

虚拟存储器与 Cache 的比较

-  相同点

   -  最终目标都是为了提高系统性能
   -  都把数据化划分为小信息块，并作为基本的传递单位
   -  都有地址的映射、替换算法、更新策略等问题
   -  依据程序访问的局部性原理应用“快速缓存的思想”，将相对活跃的数据放在相对高速的部件中

-  不同点

   -  解决问题
      -  Cache 主要解决系统速度
      -  而虚存主要解决主存容量
   -  实现方式
      -  Cache 全由硬件实现，是物理存储器
      -  虚存由 OS 和硬件共同实现，是逻辑存储器
   -  不命中时对性能的影响

      -  CPU 速度约为 Cache 10 倍
      -  主存速度约为硬盘 100 倍以上

      故虚存系统不命中对系统性能影响更大

   -  与 CPU 的连接
      -  Cache 与主存都有与 CPU 的直接通路，如果不命中 CPU 能和主存直接通信，同时将数据调入 Cache
      -  辅存与 CPU 没有直接的通路，如果不命中也要先调入主存

## 4 指令系统

软硬件的交界面，软件调用指令集中的指令，让 CPU 执行这些指令

### 4.1 指令格式

#### 4.1.1 指令的基本格式

`操作码字段 + 地址码字段`

-  操作码

   指出指令中该指令应该执行什么性质的操作和具有何种功能

   -  长度固定 用于指令字长较长的情况
   -  长度可变 操作码分散在指令字的不同字段中
   -  扩展操作码技术 操作码的位数随地址数的减少而增加，举个例子：

      -  4 位操作码，从 `0000`-`1110`，预留一位 `1111` 是干嘛的呢？看下面
      -  8 位操作码，从 `1111 0000`-`1111 1110`，咦又是预留一位，继续看下面
      -  12 位操作码，从 `1111 1111 0000`-`1111 1111 1110`，好了，现在基本上都明白了
      -  16 位操作码，从 `1111 1111 1111 0000`-`1111 1111 1111 1111`，哦这时候已经木有地址码了

      ::: tip

      -  当然，我们也可以在各个长度预留 2 位或者更多位，可以更加灵活地分配
      -  通常，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间

      :::

-  地址码

   给出被操作的信息（指令或数据）的地址

   -  零地址指令
      -  可能不需要操作数的指令
      -  可能隐含从栈顶取操作数
   -  一地址指令
      -  可能单操作数指令
      -  可能双操作数指令，隐含一个操作数在 ACC
   -  二地址指令

      即两个操作数地址

   -  三地址指令

      将两个操作数的运算结果放在第三个操作数地址内

   -  四地址指令

      将两个操作数的运算结果放在第三个操作数地址内，第四个操作数为下一条将要执行指令的地址

#### 4.1.2 指令字长

-  指令字长决定于

   -  操作码的长度
   -  操作数地址的长度
      操作数地址的个数

-  如果指令字长固定 —— 指令字长=存储字长
-  如果指令字长可变 —— 按字节的倍数变化

### 4.2 指令寻址方式

-  **形式地址** $A$ 指令字中的地址
-  **有效地址** $EA$ 操作数中的真实地址，需要形式地址与寻址特征经过一定的运算得出

> (A) 表示 A 的数值，比如 $EA = (A)$ 表示有效地址为地址 A 处所存储的数值（也就是说 `()` 有点类似于 C 语言中的取内容符 `*`）

#### 4.2.1 指令寻址

寻找**下一条将要执行的指令地址**

-  顺序寻址 $(PC) + 1 \to PC$（这里这个“1”是指指令长度，要考虑定长和非定长的情况）
-  跳跃寻址 由转移指令指出（比如 JMP）

#### 4.2.2 数据寻址

寻找**操作数的地址**，指令格式如 `操作码 寻址特征 形式地址A`，其中寻址特征标志了使用以下哪种寻址方式

-  隐含寻址

   操作数地址隐含在操作码中（某个操作数隐含在某个寄存器中，比如 ADD 指令一个操作数隐含在 ACC 中）

   -  指令字中少了一个地址字段，可缩短指令字长

-  立即寻址

   形式地址 A 中存的不是操作数的地址，而是操作数本身

   -  指令执行阶段不访存
   -  A 的位数限制了立即数的范围

-  直接寻址

   $EA = A$，有效地址就是形式地址 A

   -  执行阶段访问一次存储器
   -  A 的**位数决定**了该指令操作数的**寻址范围**
   -  操作数的地址不易修改（必须修改 A）

-  间接寻址

   $EA = (A)$，有效地址由形式地址间接提供

   -  执行指令阶段 2 次访存，访问速度过慢，一般使用寄存器间接寻址替代
   -  可扩大寻址范围
   -  便于编制程序

-  寄存器寻址

   $EA = R_i$，有效地址即为寄存器编号

   -  执行阶段不访存，只访问寄存器，执行速度快
   -  寄存器个数有限，可缩短指令字长

-  寄存器间接寻址

   $EA = (R_i)$ 有效地址在寄存器中

   -  有效地址在寄存器中，操作数在存储器中，执行阶段访存
   -  便于编制循环程序

-  相对寻址

   $EA = (PC) + A$，A 是相对于当前指令的位移量（可正可负，补码）

   -  A 的位数决定操作数的寻址范围
   -  便于程序浮动
   -  广泛用于转移指令
   -  执行指令之前 PC 就已经自增了

-  基址寻址

   -  采用专用寄存器 BR 作基址寄存器

      $EA = (BR) + A$，BR 为基址寄存器

      -  免箱操作系统，主要用于解决程序逻辑空间与存储器物理空间的无关性
      -  可扩大寻址范围
      -  有利于多道程序
      -  BR 内容由操作系统或管理程序确定
      -  在程序的执行过程中 BR 内容不变，形式地址 A 可变，但形式地址 A 位数较短

   -  采用通用寄存器作基址寄存器

      -  由用户指定哪个通用寄存器作为基址寄存器
      -  基址寄存器的内容由操作系统确定
      -  在程序的执行过程中 $R_0$ 内容不变， ==形式地址 A 可变==

-  变址寻址

   $EA = (IX) + A$，IX 为变址寄存器（专用），通用寄存器也可以作为变址寄存器

   -  可扩大寻址范围
   -  IX 的内容由用户给定
   -  在程序的执行过程中 IX 内容可变， ==形式地址 A 不可变==
   -  便于处理数组问题

-  堆栈寻址

   隐含使用栈顶指针 $SP$ 处的操作数

   -  硬堆栈 多个寄存器
   -  软堆栈 指定的存储空间

| 寻址方式           | 有效地址        | 访存次数 |
| ------------------ | --------------- | -------- |
| 隐含寻址           | 程序指定        | 0        |
| 立即寻址           | A 即是操作数    | 0        |
| 直接寻址           | $EA = A$        | 1        |
| 一次间接寻址       | $EA = (A)$      | 2        |
| 寄存器寻址         | $EA = R_i$      | 0        |
| 寄存器一次间接寻址 | $EA = (R_i)$    | 1        |
| 相对寻址           | $EA = (PC) + A$ | 1        |
| 基址寻址           | $EA = (BR) + A$ | 1        |
| 变址寻址           | $EA = (IX) + A$ | 1        |

### 4.3 CISC 和 RISC 的基本概念

指令系统发展的两个不同方向

-  CISC 增强原有指令的功能，实现软件功能的硬化
-  RISC 减少指令种类和简化指令功能，提高指令的执行速度

#### 4.3.1 复杂指令系统计算机（CISC）

-  系统指令复杂庞大，各种指令使用频度相差大
-  指令长度不固定、指令格式种类多、寻址方式多
-  访存指令不受限制
-  大多数指令需要多个时钟周期执行完毕
-  采用微程序控制器

#### 4.3.2 精简指令系统计算机（RISC）

典型程序中程序 80%的语句仅仅使用处理机中 20%的指令

所以，可以使用 20%的简单指令组合不常用的 80%的指令功能

-  选用使用频度较高的一些简单指令，复杂指令的功能由简单指令来组合
-  指令长度固定、指令格式种类少、寻址方式少
-  只有 LOAD/STORE 指令访存
-  CPU 中有多个通用寄存器
-  采用流水技术 一个时钟周期内完成一条指令
-  采用组合逻辑实现控制器

由于需要对一些老机器兼容，所以 CISC 的设计结构是不可避免的，但是 RISC 有着更高的实用性，所以现代 CISC 结构的 CPU 融合了很多 RISC 的成分，其性能差距越来越小

#### 4.3.3 CISC 和 RISC 的比较

-  RISC 更能充分利用 VLSI 芯片的面积
-  RISC 更能提高计算机运算速度
-  RISC 便于设计，可降低成本，提高可靠性
-  RISC 不易实现指令系统兼容
-  RISC 有利于编译程序代码优化

|                  | CISC                                 | RISC                                 |
| ---------------- | ------------------------------------ | ------------------------------------ |
| 指令系统         | 复杂，庞大                           | 简单，精简                           |
| 指令数目         | 一般大于 200 条                      | 一般小于 100 条                      |
| 指令字长         | 不固定                               | 定长                                 |
| 可访存指令       | 不加限制                             | 只有 Load/Store 指令                 |
| 各种指令执行时间 | 相差较大                             | 绝大多数在一个周期内完成             |
| 各种指令使用频度 | 相差很大                             | 都比较常用                           |
| 通用寄存器数量   | 较少                                 | 多                                   |
| 目标代码         | 难以用优化编译生成高效的目标代码程序 | 采用优化的编译程序，生成代码较为高效 |
| 控制方式         | 绝大多数为微程序控制                 | 绝大多数为组合逻辑控制               |
| 指令流水线       | 可以通过一定方式实现                 | 必须实现                             |

## 5 中央处理器

### 5.1 CPU 的功能和基本结构

#### 5.1.1 CPU 的功能

-  控制器的功能

   -  指令控制 取指、分析、执行
   -  操作控制 控制程序输入及结果的输出
   -  时间控制
   -  中断处理

-  运算器的功能

   -  数据加工 实现算术运算和逻辑运算

#### 5.1.2 CPU 的基本结构

-  运算器

   -  算术逻辑单元（ALU） 算术/逻辑运算
   -  暂存寄存器 暂存从主存读来的数据
   -  累加寄存器（ACC） 暂存 ALU 的结果，并可作为加法的一个输入
   -  通用寄存器组 AX、BX、CX、DX、SP 等，SP 是堆栈指针
   -  程序状态字寄存器（PSW） 保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息
   -  移位器 对操作数或运算结果进行移位运算
   -  计数器（CT） 控制乘除运算的操作步数（判断乘除法是否已结束）

-  控制器

   -  程序计数器（PC） 指出下一条指令在主存中的地址
   -  指令寄存器（IR） 保存当前正在执行的指令
   -  指令译码器 对**操作码**字段进行译码，向控制器提供特定的操作信号
   -  存储器地址寄存器（MAR） 存储所要访问的主存单元的地址
   -  存储器数据寄存器（MDR） 存储向主存写入的信息或者从主存读出的信息
   -  时序系统 产生**各种时序信号**，由统一时钟分频得到
   -  微操作信号发生器 根据 IR 的内容（指令）、PSW 的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号

### 5.2 中断系统

#### 5.2.1 引起中断的各种因素

-  人为设置的中断 如**转管指令**
-  程序性事故 溢出、操作码不能识别、除法非法
-  硬件故障
-  I/O 设备
-  外部事件 用**键盘中断**现行程序

#### 5.2.2 程序中断方式工作流程

-  中断请求

   中断源向 CPU 发送中断请求信号

   -  内中断和外中断
      -  外中断 指来自处理器和内存以外的部件引起的中断
      -  内中断 指在处理器和内存内部产生的中断
   -  硬件中断和软件中断
      -  硬件中断 通过外部的硬件产生的中断
      -  软件中断 通过某条指令产生的中断
   -  非屏蔽中断和可屏蔽中断
      -  非屏蔽中断 即便关中断也会响应
      -  可屏蔽中断 可被关中断屏蔽

-  中断判优

   按照一定的优先级进行判优，一般来说硬件故障中断最高级，其次是软件中断，非屏蔽中断优于可屏蔽中断，DMA 请求优于 I/O 设备传送的中断请求，高速设备优于低速设备，输入设备优于输出设备，实时设备优于普通设备

-  CPU 响应中断的条件

   -  中断源有中断请求
   -  CPU 允许中断及开中断
   -  一条指令执行完毕，且没有更急迫的任务

-  中断隐指令

   CPU 响应中断后，**经过某些操作**，转而执行中断服务程序，这些操作并不是真正的指令，由硬件直接实现

   -  关中断 保护中断现场（寄存器中的内容），防止被新的中断打断
   -  保存断点 将程序断点（即 PC 中的内容）暂存起来（入栈）
   -  引出中断服务程序 取出中断程序入口地址存入 PC

-  寻址中断服务程序

   -  硬件向量法 将中断程序入口地址存储在存储器某个位置，作为中断向量表
   -  软件查询法 通过命令来完成

-  中断处理过程

@flowstart
s=>start: （响应中断）
op1=>operation: 关中断
op2=>operation: 保存断点
op3=>operation: 中断服务程序寻址
op4=>operation: 保护现场和屏蔽字
op5=>operation: 开中断
op6=>operation: 执行中断服务程序
op7=>operation: 关中断
op8=>operation: 恢复现场和屏蔽字
op9=>operation: 开中断
op10=>operation: 中断返回
e=>end: （结束中断）

s->op1->op2->op3->op4->op4->op5->op6->op7->op8->op9->op10->e
@flowend

::: tip 为什么在执行中断服务程序前需要开中断？

这样才可以被更高优先级的中断打断，实现中断嵌套

:::

#### 5.2.3 多重中断和中断屏蔽技术

-  单重中断

   CPU 在执行中断过程中如果出现了新的更高优先级的中断请求，不予响应

-  多重中断

   又称中断嵌套，CPU 在执行中断过程中如果出现了新的更高优先级的中断请求，转而执行更高优先级的中断请求

   ![PCC22.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC22.png)

   -  实现多重中断的要求
      -  中断服务程序前进行“开中断”（即上节所述）
      -  优先级高的中断源有权中断优先级低的中断源
   -  屏蔽字

      使用实例说明：优先级：$D>A>C>B$，则屏蔽字应为

      ![PCC23.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC23.png)

### 5.3 指令执行过程

#### 5.3.1 指令周期

CPU 从主存中每取出并执行一条指令所需的全部时间称为指令周期，即 CPU 完成一条指令的时间

-  机器周期、节拍（状态）组成多级时序系统

   -  一个**指令周期**包含若干个**机器周期**
   -  一个**机器周期**包含若干个**时钟周期**

   ![PCC18.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC18.png)

-  完整的指令周期

   一个完整的指令周期可能包含 ==取指周期==、（ ==间址周期==）、 ==执行周期==、（ ==中断周期==）四部分（括号中为不一定出现的）

   -  取指周期 取指令
   -  间址周期 取有效地址
   -  执行周期 执行指令
   -  中断周期 中断响应

#### 5.3.2 指令周期的数据流

-  取指周期

   任务：根据 PC 中的内容从主存中取出指令代码并存入 IR

   ![PCC19.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC19.png)

   -  $PC \to MAR \to$ 地址总线
   -  $CU$ 发出控制信号 $\to$ 控制总线 $\to$ 主存
   -  主存 $\to$ 数据总线 $\to MDR \to IR$ （存放指令）
   -  $CU$ 发出读命令 $\to PC$ 内容加 1

-  间址周期

   任务：取操作数的有效地址（这里以一次间址为例）

   ![PCC20.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC20.png)

*  $Ad(IR)$ $\to$ $MAR$ $\to$ 地址总线 $\to$ 主存

   ::: tip

   -  由于此时（刚刚取指后嘛） $IR$ 与 $MDR$ 中的数据相同，所以第一步使用 $Ad(MDR)$ 也是可以的
   -  $Ad$ 是取指令中的地址字段

   :::

*  $CU$ 发出读命令 $\to$ 控制总线 $\to$ 主存
*  主存 $\to$ 数据总线 $\to MDR$ （存放有效地址）

*  执行周期

   根据指令不同而不同，没有统一的数据流向

*  中断周期

   任务：处理中断请求，假设程序断点存入堆栈，并用 $SP$ 指示栈顶地址

   ![PCC21.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC21.png)

   -  $CU$ 控制 $SP$ 减一，$SP \to MAR \to$ 地址总线 $\to$ 主存

      ::: tip

      中断周期中进栈操作是将 SP 减一而不是加一，因为计算机中的栈是向低地址增加的

      :::

   -  $CU$ 发出写命令 $\to$ 控制总线 $\to$ 主存
   -  $PC \to MDR \to$ 数据总线 $\to$ 主存（程序断点存入主存）
   -  $CU$（中断服务程序的入口地址）$\to PC$

#### 5.3.3 指令执行方案

-  单指令周期

   使用定长指令周期，所以指令周期取决于最长的指令执行时间，降低整个系统运行速度

-  多指令周期

   对不同指令选用不同的执行步骤，指令之间仍然串行执行

-  流水线方案

   指令之间可以并行执行，理想情况下每个时钟脉冲周期执行指令中的一个执行过程

### 5.4 数据通路的功能和基本结构

#### 5.4.1 数据通路的功能

数据在功能部件之间传送的路径称为数据通路

数据通路的功能是实现 CPU 内部的运算器与寄存器及寄存器之间的数据交换

#### 5.4.2 数据通路的基本结构

![PCC24.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC24.png)

-  CPU 内部单总线方式

   所有寄存器的输入输出端都连接到一条公共通路上

-  CPU 内部三总线方式

   所有寄存器输入端和输出端都连接在多条公共通路上

   略提高效率

-  专用数据通路方式

   根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的线路

   大幅提高效率，但是硬件的要求也更高了

#### 5.4.3 数据通路的数据流

-  寄存器之间的数据传送

   这里以 $PC \to MAR$ 为例

   | 步骤          | 作用                              |
   | ------------- | --------------------------------- |
   | $PC -> Bus$   | $PC_{out}$ 有效，$PC$ 内容送总线  |
   | $Bus \to MAR$ | $MAR_{in}$ 有效，总线内容送 $MAR$ |

-  主存与 CPU 之间的数据传送

   以 CPU 从主存读指令为例

   | 步骤                 | 作用                                                 |
   | -------------------- | ---------------------------------------------------- |
   | $PC \to Bus \to MAR$ | $PC_{out}$ 和$MAR_{in}$ 有效，现行指令地址 $\to MAR$ |
   | $1 \to R$            | CU 发读命令                                          |
   | $MEM(MAR) \to MDR$   | $MDR_{in}$ 有效                                      |
   | $MDR \to Bus \to IR$ | $MDR_{out}$ 和 $IR_{in}$ 有效，现行指令 $\to IR$     |

-  执行算数或逻辑运算

   以加法运算为例

   | 步骤                       | 作用                                                               |
   | -------------------------- | ------------------------------------------------------------------ |
   | $Ad(IR) \to Bus \to MAR$   | $MDR_{out} 和 $MAR\_{in}\$ 有效                                    |
   | $1 \to R$                  | CU 发读命令                                                        |
   | $MEM \to$ 数据线 $\to MDR$ | 操作数从存储器 $\to$ 数据线 $\to MDR$                              |
   | $MDR \to Bus \to Y$        | $MDR_{out}$ 和 $Y_{in}$ 有效，操作数 $\to Y$                       |
   | $(ACC) + (Y) \to Z$        | $ACC_{out}$ 和 $ALU_{in}$ 有效，CU 向 $ALU$ 发加命令，结果 $\to Z$ |
   | $Z \to ACC$                | $Z_{out}$ 和 $ACC_{in}$ 有效，结果 $\to ACC$                       |

### 5.5 控制器的功能和工作原理

#### 5.5.1 控制器的结构和功能

![PCC25.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC25.png)

#### 5.5.2 硬布线控制器

即组合逻辑控制器，由复杂的组合逻辑门电路和一些触发器构成

-  硬布线控制单元图

   ![PCC26.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC26.png)

   CU 的输入信号来源

   -  经指令译码器产生的指令信息
   -  时序系统产生的机器周期信号和节拍信号
   -  来自执行单元的反馈信息，即标志

-  硬布线控制器的微操作

   完成一条指令需要各个微操作，比如完成取指需要 $PC \to MAR$ 之后 $1 \to R$ 等等

   硬布线的设计就是根据节拍安排这一系列微操作，并利用组合逻辑门电路完成，所以，一旦控制部件构成后，除非重新设计和物理上对它重新布线，否则要想增加新的控制功能是不可能的

-  CPU 的控制方式

   -  同步控制方式

      任一微操作均有统一基准时标的时序信号控制

      -  采用定长的机器周期

         -  以最长的微操作序列和最复杂的微操作作为标准
         -  机器周期内节拍数相同

      -  采用不定长的机器周期

         -  机器周期内节拍数不等

      -  采用中央控制和局部控制相结合的方法

   -  异步控制方式

      -  无基准时标信号
      -  无固定的周期节拍和严格地时钟同步
      -  采用**应答**方式

   -  联合控制方式

      -  同步与异步相结合

   -  人工控制方式
      -  Reset
      -  连续和单条指令
      -  符合停机开关

#### 5.5.3 微程序控制器

-  微程序控制的基本概念

   ![PCC27.png{copyright:MOOC}](../img/Principles_of_Computer_Composition/PCC27.png)

   将每条机器指令编写成一个微程序，每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令

   ::: tip

   下面的概念，和程序的基本概念大多相似，都加了个“微”字

   :::

   -  微命令与微操作
      -  微操作 一条机器指令可分解为一个微操作序列，微操作是不可分割的、最小的单位（甚至到了控制一个电位信号）
      -  微命令 用于控制微操作的控制信号，与微操作一一对应
   -  微指令与微周期
      -  微指令 若干微命令的集合，至少包含两大部分
         -  操作控制字段 又称微操作码字段
         -  顺序控制字段 又称微地址码字段
      -  微周期 指从控制存储器中读取一条微指令并执行相应的微操作所需的时间
   -  微程序 伪指令的有序集合（对比于程序是指令的有序集合，另外，一条指令是由一段微程序实现的）
   -  控制存储器 CM 用于存放微程序，CPU 内部，ROM 实现（对比于主存是存放程序和数据的，CPU 外部，RAM 实现）
   -  各种寄存器
      -  微地址寄存器（CMAR）（对比于 MAR）
      -  微指令寄存器（CMDR 或 $\mu IR$）（对比于 IR）

-  微程序控制器的组成和工作过程

   -  基本组成
      ![PCC28.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC28.png)

      -  控制存储器 CM
      -  微指令寄存器 CMDR
      -  微地址形成部件 产生初始微地址和后继微地址
      -  微地址寄存器 CMAR

   -  微程序控制器的基本工作过程

      -  执行取微指令公共操作（由于任何一条机器指令的取指操作都是相同的，所以将取指编为一个微程序）
      -  由机器指令的操作码字段通过微地址形成部件产生该机器指令对应的微程序入口地址，并送入 CMAR
      -  从 CM 中逐条取出对应的微指令并执行
      -  执行完对应于一条机器指令的一个微程序后，又回到取值微程序的入口地址，继续第一步

   -  微指令的编码方式

      -  直接编码（直接控制）方式

         -  伪指令的操作控制字段中
         -  **每一位代表一个微操作指令**，某位为“1”表示该控制信号有效

         > 不需要译码，速度最快

      -  字段直接编码方式（显式编码）

         -  将微指令的控制字段分为若干“段”
         -  **每段经译码后发出控制信号**，每个字段中的命令是互斥的

         > 缩短了微指令字长，增加了译码时间

      -  字段间接编码方式（隐式编码）

         各字段译码结果不仅与本字段输入相关，还和其他字段译码结果相关

         > 进一步缩短微指令字长，但削弱了微指令并行控制能力

      -  混合编码

         直接编码和字段编码（直接和间接）混合使用

-  微指令的地址形成方式

   -  微地址下地址字段指出
   -  机器指令的操作码形成
   -  $(CMAR) + 1 \to CMAR$
   -  等等

-  微指令的格式

   -  水平型微指令

      -  一次定义并执行**多个并行操作**
      -  如：直接编码、字段直接编码、字段间接编码、直接和字段混合编码

   -  垂直型微指令
      -  类似机器指令操作码的方式
      -  由微操作码字段规定微指令的功能
      -  一条垂直型微指令只能定义并执行一种基本操作

   ::: tip 两种微指令格式的比较

   垂直型微指令的并行性并不好，所以

   -  水平型微指令比垂直型微指令**并行操作能力强，灵活性强**
   -  水平型微指令执行一条机器指令所要的微指令**数目少、速度快**
   -  水平型微指令**用较短的微程序结构喊去较长的微指令结构**
   -  水平型微指令与机器指令**差别大**

   :::

   -  混合型微指令

      在垂直型的基础上增加一些不太复杂的并行操作，微指令较短，仍便于编写，微程序也不长，执行速度加快

-  静态微程序设计和动态微程序设计

   -  静态 微程序无需改变，采用 ROM
   -  动态 通过改变微指令和微程序改变机器指令，有利于仿真，采用 EPROM

-  毫微程序设计

   -  **微程序设计**用**微程序解释机器指令**
   -  **毫微程序设计**用**毫微程序解释微指令**
   -  **毫微程序与微指令**的关系类似**微指令与机器指令**的关系

#### 5.5.4 微程序控制器与硬布线控制器的特点

-  硬布线控制器

   -  速度快
   -  设计完成后不容易加新功能，且设计繁琐

   > 随着新一代机器及 VLSI 技术的发展与不断进步，硬布线的随机逻辑设计思想又得到了重视，现代新型计算机体系结构如 RISC 中多采用硬布线控制逻辑

-  微程序控制器

   -  速度慢，需要从控制存储器中取指令
   -  规整性、灵活性、可维护性

|          | 微程序控制器                                                       | 硬布线控制器                                                       |
| -------- | ------------------------------------------------------------------ | ------------------------------------------------------------------ |
| 工作原理 | 微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可 | 微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生 |
| 执行速度 | 慢                                                                 | 快                                                                 |
| 规整性   | 较规整                                                             | 繁琐、不规整                                                       |
| 应用场合 | CISC CPU                                                           | RISC CPU                                                           |
| 易扩充性 | 易扩充修改                                                         | 困难                                                               |

### 5.6 指令流水线

#### 5.6.1 指令流水的定义

如果将一条指令划分为 `取指 分析 执行` 这三个阶段，不同指令之间可以使用什么方式并行呢？

-  顺序执行方式 $T = 3nt$
-  一次重叠执行方式 $T = (1 + 2n)t$
-  二次重叠执行方式 $T = (2 + n)t$，只是理想的，因为同时执行的三条指令不可能总是没有冲突

![PCC29.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC29.png)

#### 5.6.2 流水线方式的特点

-  把一个任务分解为几个有联系的子任务，每个子任务由一个专门功能部件完成
-  流水线每个功能段部件后面都要有一个缓冲寄存器，或称锁存器，用以保存本流水段的执行结果，供下一流水段使用
-  流水线中各功能段时间应尽量相等，否则将引起堵塞、断流
-  只有连续不断地提供同一种任务时才能发挥流水线的效率
-  流水线需要有装入时间和排空时间

#### 5.6.3 流水线的分类

-  按使用级别分
   -  部件功能级流水 将算术逻辑运算组成流水
   -  处理机级流水 将一条指令解释过程组成流水
   -  处理机间流水 将多个处理机任务组成流水
-  按可以完成的功能分
   -  单功能流水线 只能实现单一功能的流水
   -  多功能流水线
-  按同一时间内各段之间的连接方式分
   -  静态流水线 在同一时间内，流水线的各段只能按同一种功能的连接方式工作
   -  动态流水线
-  按流水线的各个功能段之间是否有反馈信号分
   -  线性流水线 从输入到输出，每个功能段只允许经过一次，不存在反馈回路
   -  非线性流水线 存在反馈回路，适合线性递归运算

#### 5.6.4 影响流水线的因素

-  结构相关（资源冲突）

   不同指令争用同意功能部件产生资源冲突

   解决方法：

   -  停顿
   -  指令存储器和数据存储器分开（哈弗结构）
   -  指令预取技术（适用于访存周期短的情况）

-  数据相关（数据冲突）

   不同指令因重叠操作，可能改变操作数

   解决方法：

   -  后推法
   -  改用旁路技术
   -  编译器优化

-  控制相关（控制冲突）

   转移指令和其他改变 PC 值的指令造成断流

   解决方法：

   -  对转移指令进行分支预测，尽早生成转移目标地址
   -  预取转移成功和不成功两个控制流方向上的目标指令
   -  加快和提前形成条件码
   -  提高转移方向的猜准率

#### 5.6.5 流水线的性能指标

-  吞吐率

   单位时间内流水线所完成指令或输出结果的数量

-  加速比$S_p$

   m 段的流水线的速度与等功能的非流水线的速度之比

-  效率

   流水线中各功能段的利用率

   由于流水线有建立时间和排空时间，因此各功能段的设备不可能一直处于工作状态

#### 5.6.6 流水线的多发技术

-  超标量技术
   -  每个时钟周期内可并发多条独立指令，配置多个功能部件
   -  不能调整指令的执行顺序，通过**编译优化**技术，把可并行执行的指令搭配起来
-  超流水线技术
   -  在**一个时钟周期**内再分段，在一个时钟周期内一个功能部件使用多次
   -  不能调整指令的执行顺序，考编译程序解决优化问题
-  超长指令字技术
   -  由编译程序挖掘出指令间潜在的并行性，**将多条能并行操作的指令组合成一条**，具有多个操作码字段的超长指令字（可达几百位）
   -  采用多个处理部件

## 6 总线

### 6.1 总线概述

#### 6.1.1 总线基本概念

-  为什么要用总线

   避免分散连接使得 CPU 难以设计（如果是分散连接，CPU 要做好多好多引脚，而且每增加一种设备 CPU 就要加一些引脚，可扩展性就很差啦）

-  总线定义

   总线是一组能为多个部件分时共享的公共信息传送线路

   -  分时 同一时刻只允许一个部件向总线发送信息
   -  共享 总线上可以挂接多个部件

-  总线设备

   -  主设备 有总线控制权
   -  从设备 被主设备访问的设备

-  总线特性

   -  机械特性 尺寸、形状、管脚数、排列顺序
   -  电气特性 传输方向和有效的电平范围
   -  功能特性 每根传输线的功能 可分为地址、数据、控制、状态反馈
   -  时间特性 信号的时序关系

-  总线上信息的传送

   -  串行
   -  并行 只适合短距离运输，各条线之间有着干扰性

   > 值得注意的是，现在串行速率比并行高，原因可参考[为什么目前的串行比并行传输快](https://www.cnblogs.com/juner/p/5514615.html)

#### 6.1.2 总线的分类

-  按功能分
   -  片内总线 芯片内部的总线
   -  系统总线 计算机系统内各功能部件之间
      -  数据总线 **双向** 与机器字长、存储字长有关
      -  地址总线 **单向** 与存储地址、I/O 地址有关
      -  控制总线 **有出 有入**
   -  通信总线 计算机系统之间或计算机系统与其他系统之间
-  按时序控制方式分
   -  同步总线
   -  异步总线
-  按数据传输格式分
   -  并行总线
   -  串行总线

#### 6.1.3 系统总线的结构

-  单总线结构

   将 CPU、主存、I/O 设备都挂在一组总线上

   ![PCC30.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC30.png)

   ::: tip

   是一组总线而不是一根总线，总线还是分为控制总线、地址总线、数据总线的

   :::

-  双总线结构

   -  主存总线
   -  I/O 总线

   ![PCC31.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC31.png)

   -  优点
      -  将低速 I/O 设备从单总线上分离出来，实现了存储器总线和 I/O 总线分离
   -  缺点
      -  需要增加通道等硬件部件

-  三总线结构

   -  主存总线
   -  I/O 总线
   -  DMA 总线

   ![PCC32.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC32.png)

   -  优点
      -  提高了 I/O 设备的性能，使其更快地响应命令，提高系统吞吐量
   -  缺点
      -  系统工作效率较低

#### 6.1.4 总线的性能指标

-  总线的传输周期 又称总线周期
-  总线时钟周期 即机器时钟周期
-  总线的工作频率 总线上各种操作的频率，总线周期倒数
-  总线时钟频率 即机器时钟频率
-  总线宽度 又称总线位宽，即数据线的根数
-  总线带宽 总线的数据传输率，即总线宽度 $\times$ 总线工作频率（注意单位）
-  总线复用 地址线与数据线复用，可以减少芯片管脚数
-  信号线数 地址线、数据线、和控制线的总和

### 6.2 总线仲裁

用于解决多个主设备同时竞争总线控制权的问题

#### 6.2.1 集中仲裁方式

总线控制逻辑基本集中于一个设备

-  链式查询方式

   所有的部件共用一根总线请求线，I/O 接口通过 BR 请求总线使用，BG 逐个向下查询，总线使用权交给遇到的第一个请求的接口，然后这个接口通过 BS 设置总线忙
   ![PCC33.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC33.png)

   -  优点
      -  优先级由连接方式事先确定（离总线控制器越近，其优先级越高）
      -  简单、增删设备很容易
   -  缺点
      -  如果某设备优先级低，很可能他的请求一直得不到应答
      -  而且对电路故障非常敏感

-  计数器定时查询方式

   I/O 接口通过 BR 请求总线使用，计数器循环累加从**设备地址线**向下查询，直到遇到第一个请求的接口，将总线使用权交由它，然后这个接口通过 BS 设置总线忙
   ![PCC34.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC34.png)

   -  优点
      -  优先级设置很灵活，甚至可以采用循环方法（每次计数的开始是上一次的终点）
   -  缺点
      -  需要 $\lceil log_2n \rceil$ 条设备地址线

-  独立请求方式

   每个接口都与控制机构有连接，控制机构有排队器
   ![PCC35.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC35.png)

   -  优点
      -  响应速度快
      -  优先级设置相当灵活
   -  缺点
      -  控制线数量多
      -  总线控制逻辑更加复杂

|          | 链式查询                             | 计数器定时查询           | 独立请求                  |
| -------- | ------------------------------------ | ------------------------ | ------------------------- |
| 控制线数 | $3$                                  | $\lceil \log_2 n \rceil$ | $2n+1$                    |
| 优点     | 优先级固定</br>结构简单</br>扩充容易 | 优先级灵活               | 响应速度快</br>优先级灵活 |
| 缺点     | 对电路故障敏感</br>优先级不灵活      | 控制线多</br>控制复杂    | 控制线多</br>控制复杂     |

#### 6.2.2 分布仲裁方式

不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器，当他们有总线请求时，就会把它们各自唯一的仲裁号发送到共享的仲裁总线上，比较优先级，最高优先级的仲裁号保留在总线

### 6.3 总线操作和定时

#### 6.3.1 总线传输的四个阶段

-  申请分配阶段
-  寻址阶段
-  传输阶段
-  结束阶段

#### 6.3.2 同步定时方式

系统**采用统一的时钟信号**来协调发送和接收双方的传输定时关系

-  优点
   -  传送速度快
   -  总线控制逻辑简单
-  缺点
   -  主从设备属于强制性同步
   -  不能及时进行数据通信的有效性检验，可靠性较差

适用于总线长度较短及总线所接部件的存取时间比较接近的系统

#### 6.3.3 异步定时方式

通过“握手”信号来实现定时控制

-  优点
   -  总线周期长度可变
-  缺点
   -  比同步控制方式稍复杂
   -  速度比同步定时方式慢

![PCC36.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC36.png)

-  不互锁方式
-  半互锁方式
-  全互锁方式

#### 6.3.4 半同步方式

**同步、异步结合**，在同步基础上增加 WAIT 信号，若其位于低电平则等待一个时钟周期后再次检测

#### 6.3.5 分离式通信

充分**挖掘**系统**总线每个瞬间**的潜力

-  主模块申请占用总线，使用完后即放弃总线的使用权
-  ~~从模块准备数据~~，解决从模块准备数据仍占用总线的问题
-  从模块申请占用总线（或者说这时它已经是主模块了），将各种信息送至总线- 特点：各模块有权申请占用总线；同步通信；准备数据不占用总线；总线被占用时无空闲

### 6.4 总线标准

#### 6.4.1 常见的总线标准

-  ISA
-  EISA
-  VESA
-  PCI
-  PCI-Express（PCI-E）
-  AGP
-  RS-232C
-  USB 通用串行总线
-  PCMCIA
-  IDE 集成设备电路
-  SCSI 小型计算机系统接口
-  SATA 串行高级技术附件

::: tip

-  USB 是通用串行总线；PCI、EISA、ISA 均是并行总线
-  USB 是用于连接外部设备的设备总线；PCI、AGP、PCI-E 是计算机系统的局部总线

:::

## 7 输入/输出系统

### 7.1 I/O 系统基本概念

#### 7.1.1 输入/输出系统

-  I/O 软件 驱动程序、用户陈旭、管理程序、升级补丁等
-  I/O 硬件 外部设备、设备控制器和接口、I/O 总线等

#### 7.1.2 I/O 控制方式

-  程序查询方式
-  程序中断方式
-  DMA 方式
-  通道方式 在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行 I/O 命令时，只需启动有关通道，通道将执行通道程序，从而完成 I/O 操作

### 7.2 外部设备

#### 7.2.1 输入设备

-  键盘
-  鼠标

#### 7.2.2 输出设备

-  显示器
   -  阴极射线管（CRT）显示器
      -  字符显示器
      -  图形显示器
   -  液晶显示器（LCD）
   -  发光二极管显示器（LED）
-  打印机
   -  针式打印机
   -  喷墨式打印机
   -  激光打印机

#### 7.2.3 [外存储器](#_3-4-辅助存储器)

### 7.3 I/O 接口

#### 7.3.1 I/O 接口的功能

-  实现主机和外设的通信联络控制
-  实现数据缓冲
-  信号格式的转换
-  传送控制命令和状态信息

#### 7.3.2 I/O 接口的基本结构

-  内部接口 内部接口与系统总线相连，数据的传输方式**只能是并行**传输
-  外部接口 通过接口电缆与外设相连，数据传输方式可能串行，因此需要串/并转换功能

::: tip 接口和端口的区别

端口指接口电路中可以进行读写的寄存器，若干端口加上相应的控制逻辑才可以组成接口

:::

#### 7.3.3 I/O 接口的类型

-  按数据传送方式
   -  并行接口
   -  串行接口
-  按主机访问 I/O 设备的控制方式
   -  程序查询接口
   -  中断接口
   -  DMA 接口
-  按通用性分类
   -  通用接口
   -  专用接口
-  按功能选择的灵活性
   -  可编程接口
   -  不可编程接口

#### 7.3.4 I/O 端口及其编址

CPU 能对数据端口执行读写操作，但对状态端口只能执行读操作，对控制端口只能执行写操作

-  统一编址 将 I/O 端口当做存储器的单元进行分配，直接适用访存指令就能访问 I/O 端口

   -  优点
      -  不需要设专门的 I/O 指令，可使 CPU 访问 I/O 更灵活、方便
      -  可使端口有较大的贬值空间
   -  缺点
      -  端口占用存储器地址，使内存容量变小
      -  执行速度慢

-  独立编址 设置专门的 I/O 指令

   -  优点
      -  程序编制清晰
   -  缺点
      -  增加了控制的复杂性

### 7.4 I/O 方式

#### 7.4.1 程序查询方式

信息的交换控制完全由主机执行程序实现，CPU 不断查询 I/O 设备状态，直到外设准备就绪

CPU 一旦启动 I/O ，就必须停止现行程序的运行，CPU 有“踏步”等待现象

#### 7.4.2 程序中断方式

CPU 在程序中安排好于某个时刻启动某台外设，然后 CPU **继续执行原来的程序**，一旦外设完成数据传送的准备工作，就主动向 CPU **发出中断请求**

#### 7.4.3 DMA 方式

完全由硬件进行成组信息传送的控制方式，在数据准备阶段，CPU 与外设并行工作

-  DMA 方式的特点

   -  使主存与 CPU 的固定联系脱钩，**主存既可以被 CPU 访问，又可被外设访问**
   -  在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现
   -  主存中要开辟专用缓冲区
   -  DMA 传送速度快，并且和 CPU 并行操作
   -  DMA 在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理

-  DMA 接口的功能和组成

   -  DMA 接口功能
      -  向 CPU 申请 DMA 传送
      -  处理总线控制权的转交
      -  管理系统总线、控制数据传送
      -  确定数据传送的首地址和长度，修正传送过程中的数据地址和长度
      -  DMA 传送结束时，给出操作完成信号
   -  DMA 接口组成
      ![PCC37.png{copyright:Wangdao}](../img/Principles_of_Computer_Composition/PCC37.png)

-  DMA 的传送方式

   -  停止 CPU 访问主存
   -  DMA 与 CPU 交替访存
   -  周期挪用（或周期窃取） 前两种的折中

-  DMA 的传送过程

   -  预处理 由 CPU 完成一些必要的准备工作
   -  数据传送 DMA 进行传输
   -  后处理 DMA 向 CPU 发送中断请求，CPU 做 DMA 结束处理

-  DMA 方式与程序中断方式的比较

   中断方式是程序的切换，需要保护和恢复现场，而 DMA 方式除了预处理和后处理，其他时候不占用 CPU 的任何资源

   |              | 中断方式     | DMA 方式     |
   | ------------ | ------------ | ------------ |
   | 数据传送     | 程序         | 硬件         |
   | 响应时间     | 指令执行结束 | 存取周期结束 |
   | 处理异常情况 | 能           | 不能         |
   | 中断请求     | 传送数据     | 后处理       |
   | 优先级       | 低           | 高           |

# References

1. 2020 年计算机组成原理考研复习指导 - 王道
2. 《计算机组成原理》 唐朔飞
3. 《Computer Organization and Design (The Hardware/Software Interface)》 David A. Patterson, John L. Hennessy
4. 《计算机科学导论》 佛罗赞、莫沙拉夫
5. 计算机组成原理（[上](https://www.icourse163.org/course/HIT-309001) & [下](https://www.icourse163.org/course/HIT-1001527001)） - 哈尔滨工业大学 - 中国大学 MOOC
6. 丁男老师课程
