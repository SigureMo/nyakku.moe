---
title: C and pointer
date: 2018-09-09
categories:
   - 倏尔·论
tags:
   - C
---

## 1 初识

不得不说，初学者学 C 语言的指针是很头疼的，时隔一年半重新学起 C 语言的我本以为这次已经很了解指针了，但是乍一学数据结构才发现，很多地方还是不得要领。

### 1.1 指针也是变量

指针是变量，emmmmmmm，貌似是废话，但是我当初刚开始学 c 的时候感觉指针是一个神圣的东西，它可以指向一个变量，好神奇的样子，然后……学不懂不学了(╯‵□′)╯︵┻━┻

不过这次再回顾这里的知识我发现不过如此嘛，指针里面不过是保存了一个一已知类型的变量的**地址**，至于这个地址多大嘛……看操作系统了，64 位占 8bytes，32 位占 4bytes，然后呐然后呐？知道地址能干嘛？知道地址当然就可以找到这个地址下的变量啦，哦对，应该只能找到 01 组成的一串字节码，而且还不知道要读多少字节才结束，这时候之前申明的类型就起作用啦，比如 char*就读 1byte，int*就读 4bytes 好啦。

### 1.2 知道了指针就可以为所欲为了哈哈

Q: 咦？为啥要用指针，以前直接拿到变量不是挺好的嘛？也可以直接对变量操作呀。

A: 如果都在 main 函数里确实也看不出来啥，但是如果把数据传到函数内进行修改的话，就只能通过返回值修改了，而且 c 只能 return1 个啊，头疼。但是如果把指针传到函数里……嘿嘿，**无论这个变量变成什么样子都能找到他，而且读写随你**。
另外，向函数里面传一个结构体啦、数组啦都要将复制很大一部分数据，而 64 位指针也不过 8bytes，也是很经济的选择。

### 1.3 动态分配内存是什么鬼

Q: 干嘛要动态分配内存啦，我不是已经声明了一个指针了变量和他的类型了嘛？干嘛还要再分配呀？

A: 但是**不知道那个指针是指向哪里**的呀，变量里的值可是随机的，指针也是变量啊，一旦里面存了哪些不该指向的地址，然后再\*p=blabla……就崩溃了……

Q: 那就给他改个可以指向的地址好了，干嘛 malloc？

A: 谁知道哪些地址可以指呀？已经知道的只有之前新建的变量，所以可以 p = &a 这样子，但是那也只能是管理变量 a 的值，**如果 p 想要有一个属于自己的一片区域的话，要自己去申请那么一片区域，之后系统就会把地址给他，当然这个地址一定是可以指的**。

## 2 结构体和对象

当初只学过 C 的我去学 Python 是各种不适应面向对象，然后现在学完各种面向对象语言再回来学 C 又是各种的不适应……当学到结构体的时候我貌似找到了对象的影子，虽然不一样，但一方面我从底层了解到了对象，另一方面我从其他语言的对象了解了结构体的意义。

### 2.1 结构体可以保存各种不同的数据

面向对象最基础的例子就是创建一个拥有 name、age 的 Person 类啦，相应地，结构体自然也可以完成这种简单的结构，如果想增加一个函数作为专有方法也是可以的，但是为啥说结构体不是类呢？可能是因为类可以对数据进行封装，主学 Python 的我对这个的认识确实不深。但是无论如何，用 c 实现的面向对象语言底层一定是是使用结构体对数据集中保存的。

### 2.2 对象的赋值与创建

在学习 Java 的面向对象可以了解到对象和基本数据并不是一种东西，而且对象的赋值并不是和基础数据一样赋‘值’，而是和原来对象的变量一起管理其内数据。如果从其底层 c 来看的话，很明显**对象的赋值只是传递指针**，而想要真正的新建一个对象的话，就要 new，用 c 来实现的话应该是 malloc 一个新的内存区域，让这个变量有一个自己管理的区域（对象）。
但是稍稍学了一点 C++又发现 C++中对象的传递与其他面向对象语言完全不同，传值便是传值。C++中新定义了一种数据类型 Reference，是一种对数据取别名的操作，底层仍然是存储地址，并没新建新的数据单元，但却是可以直接使用引用对原数据进行读写，很像 Java 对象传递时候的操作，这样看的话，**其他面向对象语言传递对象时候**说**是传递 Reference**倒更为贴切些，归根结底都只是将原对象的地址存储起来啦ヽ(￣ ▽ ￣)ﾉ

## 3 内存的结构

C 语言最大的魅力就是可以直接操作内存了，当然，这也是它最难懂的地方。之前就有在 C 语言课程中对内存的分配稍有了解，最近上过 C++与选修单片机才对内存有了进一步的了解。

### 3.1 再探指针

指针果然是一个很神奇的东西，它可以保存一个地址，但是如果学了汇编的话对地址一定不会陌生，汇编中地址可是一个一个手动分配的……C 语言最大的方便就是将地址分配的问题交由编译器完成了，我们一般不需要接触到具体的地址。
假期浏览过 C 语言进阶课程后，我对课中大地址小地址什么的一直不太明白，但是倒是明白了内存确实是有这么几个分区的，什么静态变量、局部变量等等不一定是放在一个地方的，有些是连续的，有些可能是在其他地方放着。但是经过这门课之后我大概知道了 malloc 出来的变量与指针本身并不是存在同一个地方的，有了这个基础，后面的就好理解了。

### 3.2 各区概况

先看图，来源看 Reference4
![03_C_and_pointer01.png](../Images/03_C_and_pointer01.png)
各区情况一目了然，下面主要分析一下我稍有了解的几个区

1. **Stack**，栈区，很容易就能从图上看出来，栈区是从高地址向低地址扩张的。也就是说，如果该片内存空间连续，就可以发现连续两个 int 之间地址是差 4bytes，而且是倒序的，这个现象很熟悉呀，C 进阶课程里就多次提到过，而且很巧的是，栈的内存空间连续也必须连续，因为它正是按照栈的数据结构设计的。
   先进后出，或者说后进先出，这为函数的调用提供了很大的便利，也就体现了局部变量本身的特点，只在函数内部（入栈后）有效，而函数调用后（出栈）是无效的，这也解释了为何 return 局部变量指针是丝毫没有意义的，因为其内数据很容易被之后的入栈操作所覆盖掉。
2. **Heap**，堆区，这是一片自由的区域，是我们真正自己操作的部分，但也正因为我们自己去操作，所以如果操作不好会对整个程序造成影响。
   之前多次提到了 malloc，但是 malloc 之后的数据域是在哪里呢，如果说在栈区的话，我们又是随时可以 free 的，这根本不满足后进先出的原则。没错啦，就是在这个堆区，我们可以通过 malloc 在堆区分配一个指定大小的内存空间，并将这个地址返回给某个指针，这个指针一般都是在栈区啦，这就解释了为啥他俩地址差那么多了。
   另外，堆区内存是可以向高地址扩张的，而 free 是只把那一小块 free 掉，如果多次 malloc、free 就会导致堆区的不连续，造成明明有剩余空间但是一些结构体放不下的现象，所以这个堆区还是要善加利用的。
   另外，一定要记住 free 哦，不然一方面可能导致内存空间不足，另一方面程序结束后堆区可不一定会被系统释放呦，这要看心情的( • ̀ω•́ )✧
3. **Static**，静态区，放一些全局变量和静态变量的，放在低地址区。这些不能随便改哒。
4. blabla，其他的还不知道啦，不过基本都是不能动的，这也就说明了如果声明了一个指针后如果没赋值很容易 Boom! 啦，没赋值里面的数是随机的，然后对一个不知道的地址进行写入……很可能会崩溃的

# Reference

1. [C 语言程序设计进阶 - 浙江大学 - 中国大学 MOOC](https://www.icourse163.org/course/ZJU-200001#/info)
2. [C++程序设计入门（上） - 北京邮电大学 - 网易云课堂](https://mooc.study.163.com/course/1000003015)
3. [理解 C++中引用的底层实现](https://blog.csdn.net/Mind_V/article/details/78619163)
4. [C/C++编译的程序的内存分配](https://blog.csdn.net/zcyzsy/article/details/69788884)
